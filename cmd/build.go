package cmd

import (
	"bytes"
	"dbt/log"
	"dbt/rules"
	"dbt/util"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"hash/crc32"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strings"

	"github.com/spf13/cobra"
)

const buildDirName = "BUILD"
const buildFileName = "BUILD.go"
const buildfilesDirName = "buildfiles"
const builtinDirName = "builtin"
const initFileName = "init.go"
const mainFileName = "main.go"
const moduleFileContent = "module _\ngo 1.13\n"
const moduleFileName = "go.mod"
const ninjaFileName = "build.ninja"
const rulesDirName = "/RULES/"

const initFileTemplate = `
// This file is generated. Do not edit this file.

package %s

import "_/%s/core"

type __magic_pkg struct{}

type __magic_buildable interface {
	BuildSteps() []core.BuildStep
}

func init() {
    var steps = []core.BuildStep{}

%s

	for _, step := range steps {
		step.Print()
	}
}

func in(name string) core.InFile {
	return core.NewInFile(name, __magic_pkg{})
}

func ins(names ...string) core.Files {
	var files core.Files
	for _, name := range names {
		files = append(files, in(name))
	}
	return files
}

func out(name string) core.OutFile {
	return core.NewOutFile(name, __magic_pkg{})
}
`

const mainFileTemplate = `
// This file is generated. Do not edit this file.

package main

%s

func main() {}
`

var buildCmd = &cobra.Command{
	Use:   "build <targets> -- <build flags>",
	Args:  cobra.MinimumNArgs(1),
	Short: "Builds the targets",
	Long:  `Builds the targets.`,
	Run:   runBuild,
}

func init() {
	rootCmd.AddCommand(buildCmd)
}

func runBuild(cmd *cobra.Command, args []string) {
	sourceDir := util.GetWorkspaceRoot()

	// Split all args into two categories: If they start with "--" they are considered
	// a build flag, otherwise a target to be built.
	targets := []string{}
	buildFlags := []string{}

	for _, arg := range args {
		if strings.HasPrefix(arg, "--") {
			buildFlags = append(buildFlags, arg)
			continue
		}
		// Build targets are interpreted as relative to the workspace root when they start with a '/'.
		// Otherwise they are interpreted as relative to the current working directory.
		// E.g.: Running 'dbt build /src/path/to/mylib.a' from anywhere in the workspace is equivallent
		// to running 'dbt build mylib.a' in '.../src/path/to/' or running 'dbt build path/to/mylib.a' in '.../src/'.
		if !strings.HasPrefix(arg, "/") {
			workingDir, _ := os.Getwd()
			arg = path.Join(strings.TrimPrefix(workingDir, sourceDir), arg)
		}
		targets = append(targets, strings.TrimLeft(arg, "/"))
	}

	// Create a hash from all build flags and a unique build directory for this set of flags.
	buildConfigHash := crc32.ChecksumIEEE([]byte(strings.Join(buildFlags, "#")))
	buildConfigName := fmt.Sprintf("%s-%08X", buildDirName, buildConfigHash)
	buildDir := path.Join(sourceDir, buildDirName, buildConfigName)

	log.Debug("Building targets '%s'.\n", strings.Join(targets, "', '"))
	log.Debug("Build flags: '%s'.\n", strings.Join(buildFlags, " "))
	log.Debug("Build config: '%s'.\n", buildConfigName)
	log.Debug("Source directory: '%s'.\n", sourceDir)
	log.Debug("Build directory: '%s'.\n", buildDir)

	// Remove all existing buildfiles.
	buildfilesDir := path.Join(buildDir, buildfilesDirName)
	util.RemoveDir(buildfilesDir)

	// Copy all BUILD.go files from the source directory.
	copyBuildFiles(sourceDir, buildDir, buildfilesDir)

	// Copy all files in RULES/ directories from the source directory.
	copyRuleFiles(sourceDir, buildDir, buildfilesDir)

	// Extract ll built-in build rules.
	extractBuiltinRules(buildfilesDir)

	// Compile all build files and run the resulting binary. This will produce the build.ninja file.
	generateNinjaFile(sourceDir, buildDir, buildfilesDir)

	// Call Ninja to build the targets.
	runNinja(buildDir, targets)
}

func copyBuildFiles(sourceDir, buildDir, buildfilesDir string) {
	importLines := []string{}

	err := filepath.Walk(sourceDir,
		func(filePath string, file os.FileInfo, err error) error {
			if err != nil {
				return err
			}

			if file.IsDir() || file.Name() != buildFileName || strings.HasPrefix(filePath, buildDir) {
				return nil
			}

			log.Debug("Found BUILD.go file '%s'.\n", filePath)

			relativeFilePath := strings.TrimSuffix(path.Dir(strings.TrimPrefix(filePath, sourceDir)), "/")
			importLine := fmt.Sprintf("import _ \"_%s\"\n", relativeFilePath)
			importLines = append(importLines, importLine)

			targetLines := []string{}
			packageName, targets := parseBuildFile(filePath)
			for _, targetName := range targets {
				target := fmt.Sprintf("%s/%s", relativeFilePath, targetName)
				targetLine := fmt.Sprintf(`
				if iface, ok := interface{}(%s).(__magic_buildable); ok {
					core.CurrentTarget = "%s"
					steps = append(steps, iface.BuildSteps()...)
				}`, targetName, target)
				targetLines = append(targetLines, targetLine)
			}

			initFilePath := path.Join(buildfilesDir, relativeFilePath, initFileName)
			initFileContent := fmt.Sprintf(initFileTemplate, packageName, builtinDirName, strings.Join(targetLines, "\n"))
			util.WriteFile(initFilePath, []byte(initFileContent))

			copyFilePath := path.Join(buildfilesDir, relativeFilePath, buildFileName)
			util.CopyFile(filePath, copyFilePath)
			return nil
		})

	if err != nil {
		log.Fatal("Failed to copy '%s' files: %s.\n", buildFileName, err)
	}

	moduleFilePath := path.Join(buildfilesDir, moduleFileName)
	util.WriteFile(moduleFilePath, []byte(moduleFileContent))

	mainFilePath := path.Join(buildfilesDir, builtinDirName, mainFileName)
	mainFileContent := fmt.Sprintf(mainFileTemplate, strings.Join(importLines, "\n"))
	util.WriteFile(mainFilePath, []byte(mainFileContent))
}

func parseBuildFile(buildFilePath string) (string, []string) {
	fileAst, err := parser.ParseFile(token.NewFileSet(), buildFilePath, nil, parser.AllErrors)

	if err != nil {
		log.Fatal("Failed to parse '%s': %s.\n", buildFilePath, err)
	}

	targets := []string{}

	for _, decl := range fileAst.Decls {
		decl, ok := decl.(*ast.GenDecl)
		if !ok {
			log.Fatal("'%s' contains invalid declarations. Only import statements and var declarations are allowed.\n", buildFilePath)
		}

		for _, spec := range decl.Specs {
			switch spec := spec.(type) {
			case *ast.ImportSpec:
			case *ast.ValueSpec:
				for _, id := range spec.Names {
					if decl.Tok.String() != "var" {
						log.Fatal("'%s' contains invalid target declarations: only import statements and var declarations are allowed.\n", buildFilePath)
					}
					if id.Name == "_" {
						log.Fatal("'%s' contains anonymous target declarations. All targets must be given a name.\n", buildFilePath)
					}
					targets = append(targets, id.Name)
				}
			default:
				log.Fatal("'%s' contains invalid declarations. Only import statements and var declarations are allowed.\n", buildFilePath)
			}
		}
	}

	return fileAst.Name.String(), targets
}

func copyRuleFiles(sourceDir, buildDir, buildfilesDir string) {
	err := filepath.Walk(sourceDir,
		func(filePath string, file os.FileInfo, err error) error {
			if err != nil {
				return err
			}

			if file.IsDir() || !strings.HasSuffix(file.Name(), ".go") || strings.HasPrefix(filePath, buildDir) || !strings.Contains(filePath, rulesDirName) {
				return nil
			}

			copyFilePath := path.Join(buildfilesDir, strings.TrimPrefix(filePath, sourceDir))
			util.CopyFile(filePath, copyFilePath)
			return nil
		})

	if err != nil {
		log.Fatal("Failed to copy '%s' files: %s.\n", rulesDirName, err)
	}
}

func extractBuiltinRules(buildfilesDir string) {
	for relativeFilePath, ruleFileContent := range rules.Rules {
		log.Debug("Extracting built-in rule file '%s'.\n", relativeFilePath)
		ruleFilePath := path.Join(buildfilesDir, relativeFilePath)
		util.WriteFile(ruleFilePath, []byte(ruleFileContent))
	}
}

func generateNinjaFile(sourceDir, buildDir, buildfilesDir string) {
	var stdout, stderr bytes.Buffer
	args := append([]string{"run", path.Join(builtinDirName, mainFileName), sourceDir, buildDir}, os.Args[2:]...)
	cmd := exec.Command("go", args...)
	cmd.Dir = buildfilesDir
	cmd.Stderr = &stderr
	cmd.Stdout = &stdout
	err := cmd.Run()
	fmt.Println(string(stderr.Bytes()))
	if err != nil {
		log.Fatal("Failed to generate ninja file.\n")
	}

	ninjaFilePath := path.Join(buildDir, ninjaFileName)
	util.WriteFile(ninjaFilePath, stdout.Bytes())
}

func runNinja(buildDir string, targets []string) {
	cmd := exec.Command("ninja", targets...)
	cmd.Dir = buildDir
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	err := cmd.Run()
	if err != nil {
		log.Fatal("Build failed.\n")
	}
}
