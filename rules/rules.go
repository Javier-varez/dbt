
// This file is generated. Do not edit this file.

package rules

//go:generate go run embed/embed.go

var Rules = map[string]string{
    "builtin/cc/cc.go": `package cc

import (
	"fmt"
	"strings"

	"_/builtin/core"
)

type Toolchain struct {
	Cc string
	Ar string
}

var defaultToolchain = Toolchain{
	Cc: "gcc",
	Ar: "ar",
}

type Flags struct {
	Includes       []string
	SystemIncludes []string
	CFlags         []string
	LdFlags        []string
}

func (flags *Flags) CompileFlags() string {
	cflags := []string{"-c"}
	cflags = append(cflags, flags.CFlags...)
	for _, include := range flags.Includes {
		cflags = append(cflags, fmt.Sprintf("-I%s", include))
	}
	for _, include := range flags.SystemIncludes {
		cflags = append(cflags, fmt.Sprintf("-isystem %s", include))
	}
	return strings.Join(cflags, " ")
}

type ObjectFile struct {
	Src       core.File
	Flags     Flags
	Toolchain *Toolchain
}

func (obj ObjectFile) Out() core.OutFile {
	return obj.Src.WithExt("o")
}

func (obj ObjectFile) BuildSteps(target string) core.BuildSteps {
	if obj.Toolchain == nil {
		obj.Toolchain = &defaultToolchain
	}

	cmd := fmt.Sprintf("%s %s -o %s %s", obj.Toolchain.Cc, obj.Flags.CompileFlags(), obj.Out(), obj.Src)
	return core.BuildSteps{{
		Out:   obj.Out(),
		In:    obj.Src,
		Cmd:   cmd,
		Descr: fmt.Sprintf("CC %s", obj.Out().RelPath()),
		Alias: obj.Out().RelPath(),
	}}
}

type Library struct {
	Out       core.OutFile
	Srcs      core.Files
	Deps      []Library
	Toolchain *Toolchain
}

func (lib Library) BuildSteps(target string) core.BuildSteps {
	core.Assert(!lib.Out.Empty(), "'Out' is missing, but required", target)

	if lib.Toolchain == nil {
		lib.Toolchain = &defaultToolchain
	}

	var steps = core.BuildSteps{}
	var objs = core.Files{}

	for _, src := range lib.Srcs {
		obj := ObjectFile{
			Src:       src,
			Toolchain: lib.Toolchain,
		}
		objs = append(objs, obj.Out())
		steps = append(steps, obj.BuildSteps(target)...)
	}

	cmd := fmt.Sprintf("%s rv %s %s > /dev/null", lib.Toolchain.Ar, lib.Out, objs)
	linkStep := core.BuildStep{
		Out:   lib.Out,
		Ins:   objs,
		Cmd:   cmd,
		Descr: fmt.Sprintf("AR %s", lib.Out.RelPath()),
		Alias: lib.Out.RelPath(),
	}

	return append(steps, linkStep)
}

type Binary struct {
	Out  core.OutFile
	Srcs core.Files
	Deps []Library
}
`,

    "builtin/core/file.go": `package core

import (
	"fmt"
	"os"
	"path"
	"reflect"
	"strings"
)

func sourceDir() string {
	return os.Args[1]
}

func buildDir() string {
	return os.Args[2]
}

type File interface {
	Empty() bool
	Path() string
	RelPath() string
	WithExt(ext string) OutFile
	WithSuffix(suffix string) OutFile
}

type Files []File

func (fs Files) String() string {
	paths := []string{}
	for _, f := range fs {
		paths = append(paths, fmt.Sprint(f))
	}
	return strings.Join(paths, " ")
}

type files interface {
	Files() Files
}

func (fs Files) Files() Files {
	return fs
}

func Flatten(fss ...files) Files {
	files := Files{}
	for _, fs := range fss {
		files = append(files, fs.Files()...)
	}
	return files
}

type InFile struct {
	relPath string
}

func (f InFile) Empty() bool {
	return f.relPath == ""
}

func (f InFile) Path() string {
	return path.Join(sourceDir(), f.relPath)
}

func (f InFile) RelPath() string {
	return f.relPath
}

func (f InFile) WithExt(ext string) OutFile {
	return OutFile{f.relPath}.WithExt(ext)
}

func (f InFile) WithSuffix(suffix string) OutFile {
	return OutFile{f.relPath}.WithSuffix(suffix)
}

func (f InFile) String() string {
	return fmt.Sprintf("\"%s\"", f.Path())
}

type OutFile struct {
	relPath string
}

func (f OutFile) Empty() bool {
	return f.relPath == ""
}

func (f OutFile) Path() string {
	return path.Join(buildDir(), f.relPath)
}

func (f OutFile) RelPath() string {
	return f.relPath
}

func (f OutFile) WithExt(ext string) OutFile {
	oldExt := path.Ext(f.relPath)
	relPath := fmt.Sprintf("%s.%s", strings.TrimSuffix(f.relPath, oldExt), ext)
	return OutFile{relPath}
}

func (f OutFile) WithSuffix(suffix string) OutFile {
	return OutFile{f.relPath + suffix}
}

func (f OutFile) String() string {
	return fmt.Sprintf("\"%s\"", f.Path())
}

func NewInFile(name string, pkg interface{}) InFile {
	pkgPath := reflect.TypeOf(pkg).PkgPath()
	p := path.Join(strings.TrimPrefix(pkgPath, "_/"), name)
	return InFile{p}
}

func NewOutFile(name string, pkg interface{}) OutFile {
	pkgPath := reflect.TypeOf(pkg).PkgPath()
	p := path.Join(strings.TrimPrefix(pkgPath, "_/"), name)
	return OutFile{p}
}
`,

    "builtin/core/step.go": `package core

import (
	"fmt"
	"strings"
)

type BuildStep struct {
	Out   OutFile
	In    File
	Ins   Files
	Cmd   string
	Descr string
	Alias string
}

type BuildSteps []BuildStep

var nextRuleId = 1

func ninjaEscape(s string) string {
	return strings.ReplaceAll(s, " ", "$ ")
}

func (step BuildStep) Print() {
	ins := []string{}
	for _, in := range step.Ins {
		ins = append(ins, ninjaEscape(in.Path()))
	}
	if step.In != nil {
		ins = append(ins, ninjaEscape(step.In.Path()))
	}

	alias := ninjaEscape(step.Alias)
	out := ninjaEscape(step.Out.Path())

	fmt.Printf("rule r%d\n", nextRuleId)
	fmt.Printf("  command = %s\n", step.Cmd)
	if step.Descr != "" {
		fmt.Printf("  description = %s\n", step.Descr)
	}
	fmt.Print("\n")
	fmt.Printf("build %s: r%d %s\n", out, nextRuleId, strings.Join(ins, " "))
	if alias != "" {
		fmt.Print("\n")
		fmt.Printf("build %s: phony %s\n", alias, out)
	}
	fmt.Print("\n\n")

	nextRuleId++
}
`,

    "builtin/core/util.go": `package core

import (
	"fmt"
	"os"
	"strings"
)

func Flag(name string) string {
	prefix := fmt.Sprintf("--%s=", name)
	for _, arg := range os.Args[3:] {
		if strings.HasPrefix(arg, prefix) {
			return strings.TrimPrefix(arg, prefix)
		}
	}
	return ""
}

func Assert(cond bool, msg string, target string) {
	if !cond {
		fmt.Fprintf(os.Stderr, "Assertion failed while processing target '%s': %s.\n", target, msg)
		os.Exit(1)
	}
}
`,

}
